<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Superposition & Interference Simulation - p6sims</title>
    <link rel="stylesheet" href="../../style.css">
    <style>
        /* Simulation Specific Overrides */
        .simulation-wrapper {
            max-width: 950px;
            /* Wider for dual controls */
        }

        .controls-wrapper {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .controls-panel {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: 1.25rem;
        }

        .controls-panel h2 {
            font-size: 1rem;
            color: var(--primary-color);
            margin-top: 0;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .control-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-item label {
            min-width: 100px;
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .control-item input[type="range"] {
            flex-grow: 1;
        }

        .value-display {
            min-width: 50px;
            text-align: right;
            font-size: 0.8rem;
            background-color: var(--bg-secondary);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: var(--text-primary);
        }

        .global-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        .show-hide-toggles {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
        }

        .show-hide-toggles label {
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            user-select: none;
        }

        .info-panel {
            text-align: center;
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
            background-color: var(--bg-secondary);
            padding: 0.75rem;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .info-panel strong {
            color: var(--primary-color);
            font-weight: 600;
        }

        canvas#superpositionCanvas {
            width: 100%;
            height: 400px;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            margin-bottom: 1.5rem;
        }

        /* Notes Section (Shared Style) */
        .notes-section {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            overflow: hidden;
        }

        .notes-header {
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .notes-header h3 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .notes-header::after {
            content: '▸';
            font-size: 1.2rem;
            color: var(--text-secondary);
            transition: transform 0.2s ease;
        }

        .notes-section.notes-open .notes-header::after {
            transform: rotate(90deg);
        }

        .notes-content {
            display: none;
            padding: 1.5rem;
            font-size: 0.95rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .notes-section.notes-open .notes-content {
            display: block;
        }

        .note-block {
            margin-bottom: 1.5rem;
        }

        .note-block:last-child {
            margin-bottom: 0;
        }

        .note-block h4 {
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .note-block ul {
            padding-left: 1.5rem;
            margin-top: 0.5rem;
        }

        .note-block li {
            margin-bottom: 0.25rem;
        }

        code {
            background: var(--bg-secondary);
            padding: 0.1em 0.3em;
            border-radius: 3px;
            font-size: 0.9em;
            color: var(--primary-color);
        }

        .lang-button {
            padding: 4px 10px;
            font-size: 0.75rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .lang-button:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        /* Variables for Canvas Drawing */
        :root {
            --wave1-color: rgba(59, 130, 246, 0.8);
            /* Blue-500 */
            --wave2-color: rgba(16, 185, 129, 0.8);
            /* Emerald-500 */
            --resultant-wave-color: #6366f1;
            /* Indigo-500 */
            --particle-color-super: #f43f5e;
            /* Rose-500 */
        }
    </style>
</head>

<body>

    <header class="site-header">
        <div class="header-content">
            <a href="../../index.html" class="logo">p6sims</a>
            <nav class="site-nav">
                <a href="../../index.html#topics">Topics</a>
                <a href="../../index.html#about">About</a>
            </nav>
        </div>
    </header>

    <main class="container">
        <div class="simulation-wrapper">
            <div class="back-link">
                <a href="../../waves-vibration.html">← Back to Waves & Vibration</a>
            </div>

            <h1>Wave Superposition & Interference</h1>

            <div class="controls-wrapper">
                <div class="controls-panel" id="wave1Controls">
                    <h2>Wave 1</h2>
                    <div class="control-group">
                        <div class="control-item"><label for="amplitude1">Amplitude (A₁)</label><input type="range"
                                id="amplitude1" min="0" max="100" value="40"><span id="amplitude1Value"
                                class="value-display">40</span></div>
                        <div class="control-item"><label for="wavelength1">Wavelength (λ₁)</label><input type="range"
                                id="wavelength1" min="50" max="500" value="200"><span id="wavelength1Value"
                                class="value-display">200</span></div>
                        <div class="control-item"><label for="frequency1">Frequency (f₁)</label><input type="range"
                                id="frequency1" min="0.1" max="2" step="0.1" value="0.5"><span id="frequency1Value"
                                class="value-display">0.5 Hz</span></div>
                        <div class="control-item"><label for="phase1">Initial Phase (φ₁)</label><input type="range"
                                id="phase1" min="0" max="360" step="1" value="0"><span id="phase1Value"
                                class="value-display">0°</span></div>
                    </div>
                </div>
                <div class="controls-panel" id="wave2Controls">
                    <h2>Wave 2</h2>
                    <div class="control-group">
                        <div class="control-item"><label for="amplitude2">Amplitude (A₂)</label><input type="range"
                                id="amplitude2" min="0" max="100" value="40"><span id="amplitude2Value"
                                class="value-display">40</span></div>
                        <div class="control-item"><label for="wavelength2">Wavelength (λ₂)</label><input type="range"
                                id="wavelength2" min="50" max="500" value="200"><span id="wavelength2Value"
                                class="value-display">200</span></div>
                        <div class="control-item"><label for="frequency2">Frequency (f₂)</label><input type="range"
                                id="frequency2" min="0.1" max="2" step="0.1" value="0.5"><span id="frequency2Value"
                                class="value-display">0.5 Hz</span></div>
                        <div class="control-item"><label for="phase2">Initial Phase (φ₂)</label><input type="range"
                                id="phase2" min="0" max="360" step="1" value="0"><span id="phase2Value"
                                class="value-display">0°</span></div>
                    </div>
                </div>
            </div>

            <div class="show-hide-toggles">
                <label><input type="checkbox" id="showWave1" checked> Show Wave 1</label>
                <label><input type="checkbox" id="showWave2" checked> Show Wave 2</label>
                <label><input type="checkbox" id="showResultant" checked> Show Resultant</label>
                <label><input type="checkbox" id="showParticles" checked> Show Particles</label>
            </div>

            <div class="info-panel">
                Wave 1 Speed (v₁): <strong id="speed1Value">0 m·s⁻¹</strong> | Wave 2 Speed (v₂): <strong
                    id="speed2Value">0 m·s⁻¹</strong>
            </div>

            <canvas id="superpositionCanvas"></canvas>

            <div class="global-controls">
                <button id="pausePlayButtonSuper" class="btn btn-primary">Pause</button>
                <button id="resetTimeButtonSuper" class="btn btn-secondary">Reset Time</button>
            </div>

            <section id="notesSectionSuper" class="notes-section" style="margin-top: 2rem;">
                <div class="notes-header">
                    <h3 data-lang-key="notesTitleSuper">Superposition: Key Concepts</h3>
                    <button id="langToggleButtonSuper" class="lang-button" title="Change notes language">தமிழ்</button>
                </div>
                <div class="notes-content">
                    <div class="note-block">
                        <h4 data-lang-key="superPrincipleTitle">Principle of Superposition</h4>
                        <p data-lang-key="superPrincipleDesc">When two or more waves travel through the same medium at
                            the same time, the resultant displacement of the medium at any point is the algebraic sum of
                            the displacements of the individual
                            waves.<br><code>y_resultant(x,t) = y₁(x,t) + y₂(x,t)</code></p>
                    </div>
                    <div class="note-block">
                        <h4 data-lang-key="interferenceTitle">Interference</h4>
                        <p data-lang-key="interferenceDesc">Interference is the phenomenon that occurs when two waves
                            meet while traveling along the same medium. It results in the formation of a new wave
                            pattern.</p>
                        <ul>
                            <li data-lang-key="constructiveDesc"><strong>Constructive Interference:</strong> Occurs when
                                waves add up to make a larger amplitude resultant wave (e.g., crest meets crest). This
                                happens when waves are in phase (or phase difference is a multiple of 2π or 360°).</li>
                            <li data-lang-key="destructiveDesc"><strong>Destructive Interference:</strong> Occurs when
                                waves add up to make a smaller amplitude (or zero) resultant wave (e.g., crest meets
                                trough). This happens when waves are out of phase (phase difference is an odd multiple
                                of π or 180°).</li>
                        </ul>
                    </div>
                    <div class="note-block">
                        <h4 data-lang-key="beatsTitle">Beats (f₁ ≈ f₂)</h4>
                        <p data-lang-key="beatsDesc">If two waves of slightly different frequencies interfere, the
                            resultant amplitude varies periodically over time, creating "beats". The beat frequency is
                            <code>f_beat = |f₁ - f₂|</code>.</p>
                    </div>
                    <div class="note-block">
                        <h4 data-lang-key="standingTitle">Standing Waves (Conceptual)</h4>
                        <p data-lang-key="standingDesc">If two identical waves (same A, f, λ) travel in opposite
                            directions, they can form a standing wave, which has fixed points of zero amplitude (nodes)
                            and maximum amplitude (antinodes). (This simulation primarily shows co-directional waves).
                        </p>
                    </div>
                    <div class="note-block">
                        <h4 data-lang-key="tipsSuperTitle">Simulation Tips</h4>
                        <ul>
                            <li data-lang-key="tipPhaseSuper">Adjust initial phases (φ₁ & φ₂) to observe constructive
                                and destructive interference. Try making them 0° and 180° apart.</li>
                            <li data-lang-key="tipFreqSuper">Set frequencies (f₁ & f₂) very close to each other to
                                observe the beat phenomenon (slow amplitude modulation of the resultant wave).</li>
                            <li data-lang-key="tipEqualSuper">Set A₁=A₂, f₁=f₂, λ₁=λ₂ and φ₁=0°, φ₂=180° for maximum
                                destructive interference.</li>
                        </ul>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <footer class="site-footer">
        <p>&copy; 2023 p6sims. Built by <a href="https://www.instagram.com/hai_faizul/" target="_blank">Hai</a>.</p>
    </footer>

    <script>
        const canvas = document.getElementById('superpositionCanvas');
        const ctx = canvas.getContext('2d');

        const amp1Slider = document.getElementById('amplitude1'); const lambda1Slider = document.getElementById('wavelength1'); const freq1Slider = document.getElementById('frequency1'); const phase1Slider = document.getElementById('phase1');
        const amp1ValSpan = document.getElementById('amplitude1Value'); const lambda1ValSpan = document.getElementById('wavelength1Value'); const freq1ValSpan = document.getElementById('frequency1Value'); const phase1ValSpan = document.getElementById('phase1Value'); const speed1ValSpan = document.getElementById('speed1Value');
        const amp2Slider = document.getElementById('amplitude2'); const lambda2Slider = document.getElementById('wavelength2'); const freq2Slider = document.getElementById('frequency2'); const phase2Slider = document.getElementById('phase2');
        const amp2ValSpan = document.getElementById('amplitude2Value'); const lambda2ValSpan = document.getElementById('wavelength2Value'); const freq2ValSpan = document.getElementById('frequency2Value'); const phase2ValSpan = document.getElementById('phase2Value'); const speed2ValSpan = document.getElementById('speed2Value');
        const pausePlayBtn = document.getElementById('pausePlayButtonSuper'); const resetTimeBtn = document.getElementById('resetTimeButtonSuper');
        const showWave1Check = document.getElementById('showWave1'); const showWave2Check = document.getElementById('showWave2'); const showResultantCheck = document.getElementById('showResultant'); const showParticlesCheck = document.getElementById('showParticles');

        let A1_target, lambda1, f1, phi1_rad, k1, omega1, v1;
        let A2_target, lambda2, f2, phi2_rad, k2, omega2, v2;
        let A1_current = 0, A2_current = 0;
        const RAMP_UP_DURATION = 0.5; // seconds
        let wave1RampActive = false, wave2RampActive = false;
        let wave1RampProgress = 0, wave2RampProgress = 0; // 0 to 1

        let numParticlesSuper = 30; let highlightedParticleIndexSuper = -1; let particlesSuper = [];
        let timeSuper = 0; let isPausedSuper = false; let lastTimestampSuper = 0; let animationFrameIdSuper = null;

        function triggerRampUp(waveNum) {
            if (waveNum === 1 && showWave1Check.checked && A1_target > 0) {
                wave1RampActive = true; wave1RampProgress = A1_current / A1_target; // Start ramp from current visual amplitude
            }
            if (waveNum === 2 && showWave2Check.checked && A2_target > 0) {
                wave2RampActive = true; wave2RampProgress = A2_current / A2_target;
            }
        }

        function updateParametersSuperposition() {
            // Store old target amplitudes to see if they changed, triggering ramp
            const old_A1_target = A1_target;
            const old_A2_target = A2_target;

            A1_target = parseFloat(amp1Slider.value); lambda1 = parseFloat(lambda1Slider.value); f1 = parseFloat(freq1Slider.value); phi1_rad = parseFloat(phase1Slider.value) * Math.PI / 180;
            amp1ValSpan.textContent = A1_target.toFixed(0); lambda1ValSpan.textContent = lambda1.toFixed(0); freq1ValSpan.textContent = f1.toFixed(1) + " Hz"; phase1ValSpan.textContent = (phi1_rad * 180 / Math.PI).toFixed(0) + "°";
            k1 = 2 * Math.PI / lambda1; omega1 = 2 * Math.PI * f1; v1 = f1 * lambda1; speed1ValSpan.innerHTML = `${v1.toFixed(1)} m·s<sup>-1</sup>`;

            A2_target = parseFloat(amp2Slider.value); lambda2 = parseFloat(lambda2Slider.value); f2 = parseFloat(freq2Slider.value); phi2_rad = parseFloat(phase2Slider.value) * Math.PI / 180;
            amp2ValSpan.textContent = A2_target.toFixed(0); lambda2ValSpan.textContent = lambda2.toFixed(0); freq2ValSpan.textContent = f2.toFixed(1) + " Hz"; phase2ValSpan.textContent = (phi2_rad * 180 / Math.PI).toFixed(0) + "°";
            k2 = 2 * Math.PI / lambda2; omega2 = 2 * Math.PI * f2; v2 = f2 * lambda2; speed2ValSpan.innerHTML = `${v2.toFixed(1)} m·s<sup>-1</sup>`;

            if (showWave1Check.checked && A1_target > 0 && (A1_target !== old_A1_target || !wave1RampActive && A1_current < A1_target)) triggerRampUp(1);
            if (showWave2Check.checked && A2_target > 0 && (A2_target !== old_A2_target || !wave2RampActive && A2_current < A2_target)) triggerRampUp(2);


            particlesSuper = []; highlightedParticleIndexSuper = -1;
            if (numParticlesSuper > 0 && canvas.width > 0) { const particleSpacing = canvas.width / (numParticlesSuper + 1); for (let i = 0; i < numParticlesSuper; i++) { particlesSuper.push({ originalX: particleSpacing * (i + 1) }); } if (numParticlesSuper > 0) { highlightedParticleIndexSuper = Math.floor((numParticlesSuper - 1) / 2); } }
            if (isPausedSuper) { drawFrameSuperposition(); } else if (!animationFrameIdSuper) { lastTimestampSuper = performance.now(); animationFrameIdSuper = requestAnimationFrame(animateSuperposition); }
        }

        function drawWaveShape(ctx, amplitude, k, omega, phase, time, color, lineDash = [], lineWidth = 1.5) { if (amplitude < 0.1) return; ctx.beginPath(); const y_center = canvas.height / 2; ctx.moveTo(0, y_center + amplitude * Math.sin(k * 0 - omega * time + phase)); for (let x = 1; x <= canvas.width; x++) { const y_offset = amplitude * Math.sin(k * x - omega * time + phase); ctx.lineTo(x, y_center + y_offset); } ctx.strokeStyle = color; ctx.lineWidth = lineWidth; ctx.setLineDash(lineDash); ctx.stroke(); ctx.setLineDash([]); }
        function drawParticlesSuperposition(y_center) { if (!showParticlesCheck.checked || particlesSuper.length === 0) return; const particleRadius = 4; const defaultParticleColor = getComputedStyle(document.documentElement).getPropertyValue('--particle-color-super').trim(); const highlightParticleColor = getComputedStyle(document.documentElement).getPropertyValue('--highlight-color').trim(); let maxPossibleVisualAmplitude = Math.min((showWave1Check.checked ? A1_target : 0) + (showWave2Check.checked ? A2_target : 0), canvas.height / 2 - 10); if (maxPossibleVisualAmplitude < 5) maxPossibleVisualAmplitude = A1_target > A2_target ? A1_target : A2_target; maxPossibleVisualAmplitude = Math.min(maxPossibleVisualAmplitude, canvas.height / 2 - 10); if (maxPossibleVisualAmplitude < 5) maxPossibleVisualAmplitude = 10; particlesSuper.forEach((particle, index) => { const equilibriumX = particle.originalX; const y1_val = showWave1Check.checked ? A1_current * Math.sin(k1 * equilibriumX - omega1 * timeSuper + phi1_rad) : 0; const y2_val = showWave2Check.checked ? A2_current * Math.sin(k2 * equilibriumX - omega2 * timeSuper + phi2_rad) : 0; const resultant_y_offset = y1_val + y2_val; let currentMaxOscillationPath = maxPossibleVisualAmplitude; ctx.beginPath(); ctx.moveTo(equilibriumX, y_center - currentMaxOscillationPath); ctx.lineTo(equilibriumX, y_center + currentMaxOscillationPath); ctx.strokeStyle = 'rgba(150, 150, 150, 0.4)'; ctx.setLineDash([2, 3]); ctx.lineWidth = 1; ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle = (index === highlightedParticleIndexSuper) ? highlightParticleColor : defaultParticleColor; ctx.beginPath(); ctx.arc(equilibriumX, y_center + resultant_y_offset, particleRadius, 0, 2 * Math.PI); ctx.fill(); }); }

        function drawFrameSuperposition() {
            if (!ctx || !canvas) return;
            const deltaTimeFrame = (lastTimestampSuper && timeSuper > 0 && !isPausedSuper) ? (performance.now() - lastTimestampSuper) / 1000 : 1 / 60; // Estimate if no prev ts

            ctx.clearRect(0, 0, canvas.width, canvas.height); const y_center = canvas.height / 2; ctx.beginPath(); ctx.moveTo(0, y_center); ctx.lineTo(canvas.width, y_center); ctx.strokeStyle = 'rgba(150, 150, 150, 0.6)'; ctx.setLineDash([4, 4]); ctx.lineWidth = 1; ctx.stroke(); ctx.setLineDash([]);
            if (wave1RampActive && showWave1Check.checked) { wave1RampProgress += deltaTimeFrame / RAMP_UP_DURATION; A1_current = A1_target * Math.min(1, wave1RampProgress); if (wave1RampProgress >= 1) { wave1RampActive = false; A1_current = A1_target; } } else if (!showWave1Check.checked) { A1_current = 0; wave1RampActive = false; wave1RampProgress = 0; } else if (showWave1Check.checked) { A1_current = A1_target; } // Ensure it stays at target if not ramping
            if (wave2RampActive && showWave2Check.checked) { wave2RampProgress += deltaTimeFrame / RAMP_UP_DURATION; A2_current = A2_target * Math.min(1, wave2RampProgress); if (wave2RampProgress >= 1) { wave2RampActive = false; A2_current = A2_target; } } else if (!showWave2Check.checked) { A2_current = 0; wave2RampActive = false; wave2RampProgress = 0; } else if (showWave2Check.checked) { A2_current = A2_target; }

            if (showWave1Check.checked) { drawWaveShape(ctx, A1_current, k1, omega1, phi1_rad, timeSuper, getComputedStyle(document.documentElement).getPropertyValue('--wave1-color').trim(), [5, 5]); }
            if (showWave2Check.checked) { drawWaveShape(ctx, A2_current, k2, omega2, phi2_rad, timeSuper, getComputedStyle(document.documentElement).getPropertyValue('--wave2-color').trim(), [3, 3]); }
            if (showResultantCheck.checked && (showWave1Check.checked || showWave2Check.checked)) { ctx.beginPath(); const y1_start = showWave1Check.checked ? (A1_current * Math.sin(k1 * 0 - omega1 * timeSuper + phi1_rad)) : 0; const y2_start = showWave2Check.checked ? (A2_current * Math.sin(k2 * 0 - omega2 * timeSuper + phi2_rad)) : 0; ctx.moveTo(0, y_center + y1_start + y2_start); for (let x = 1; x <= canvas.width; x++) { const y1 = showWave1Check.checked ? (A1_current * Math.sin(k1 * x - omega1 * timeSuper + phi1_rad)) : 0; const y2 = showWave2Check.checked ? (A2_current * Math.sin(k2 * x - omega2 * timeSuper + phi2_rad)) : 0; ctx.lineTo(x, y_center + y1 + y2); } ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--resultant-wave-color').trim(); ctx.lineWidth = 2; ctx.stroke(); }
            drawParticlesSuperposition(y_center);
        }

        function animateSuperposition(timestamp) { if (!isPausedSuper) { if (!lastTimestampSuper) lastTimestampSuper = timestamp; const deltaTime = (timestamp - lastTimestampSuper) / 1000; lastTimestampSuper = timestamp; if (!isNaN(deltaTime) && deltaTime > 0 && deltaTime < 0.5) timeSuper += deltaTime; } drawFrameSuperposition(); if (!isPausedSuper) animationFrameIdSuper = requestAnimationFrame(animateSuperposition); else { if (animationFrameIdSuper) cancelAnimationFrame(animationFrameIdSuper); animationFrameIdSuper = null; } }

        [amp1Slider, lambda1Slider, freq1Slider, phase1Slider, amp2Slider, lambda2Slider, freq2Slider, phase2Slider].forEach(slider => { slider.addEventListener('input', updateParametersSuperposition); });
        [showWave1Check, showWave2Check, showResultantCheck, showParticlesCheck].forEach(check => { check.addEventListener('change', () => { if (check.id === 'showWave1' && check.checked && A1_target > 0 && A1_current < A1_target) triggerRampUp(1); else if (check.id === 'showWave1' && !check.checked) { A1_current = 0; wave1RampActive = false; wave1RampProgress = 0; } if (check.id === 'showWave2' && check.checked && A2_target > 0 && A2_current < A2_target) triggerRampUp(2); else if (check.id === 'showWave2' && !check.checked) { A2_current = 0; wave2RampActive = false; wave2RampProgress = 0; } if (isPausedSuper) drawFrameSuperposition(); }); });
        pausePlayBtn.addEventListener('click', () => { isPausedSuper = !isPausedSuper; pausePlayBtn.textContent = isPausedSuper ? 'Play' : 'Pause'; if (!isPausedSuper) { lastTimestampSuper = performance.now(); if (!animationFrameIdSuper) animationFrameIdSuper = requestAnimationFrame(animateSuperposition); } else { if (animationFrameIdSuper) cancelAnimationFrame(animationFrameIdSuper); animationFrameIdSuper = null; } });
        resetTimeBtn.addEventListener('click', () => { timeSuper = 0; A1_current = 0; A2_current = 0; wave1RampProgress = 0; wave2RampProgress = 0; if (showWave1Check.checked && A1_target > 0) triggerRampUp(1); if (showWave2Check.checked && A2_target > 0) triggerRampUp(2); if (isPausedSuper) drawFrameSuperposition(); else { lastTimestampSuper = performance.now(); if (!animationFrameIdSuper) animationFrameIdSuper = requestAnimationFrame(animateSuperposition); } });

        const langToggleButtonSuper = document.getElementById('langToggleButtonSuper'); let currentNotesLanguageSuper = 'en';
        const languageDataSuper = { notesTitleSuper: { en: "Superposition: Key Concepts", ta: "மேற்பொருந்துதல்: முக்கிய கருத்துகள்" }, superPrincipleTitle: { en: "Principle of Superposition", ta: "மேற்பொருந்துதல் தத்துவம்" }, superPrincipleDesc: { en: "When two or more waves travel through the same medium at the same time, the resultant displacement of the medium at any point is the algebraic sum of the displacements of the individual waves.<br><code>y_resultant(x,t) = y₁(x,t) + y₂(x,t)</code>", ta: "ஒரே நேரத்தில் இரண்டு அல்லது அதற்கு மேற்பட்ட அலைகள் ஒரே ஊடகத்தின் வழியே பயணிக்கும்போது, எந்தவொரு புள்ளியிலும் ஊடகத்தின் விளைவான இடப்பெயர்ச்சி என்பது தனிப்பட்ட அலைகளின் இடப்பெயர்ச்சிகளின் இயற்கணித கூட்டுத்தொகையாகும்.<br><code>y_விளைவு(x,t) = y₁(x,t) + y₂(x,t)</code>" }, interferenceTitle: { en: "Interference", ta: "குறுக்கீட்டு விளைவு" }, interferenceDesc: { en: "Interference is the phenomenon that occurs when two waves meet while traveling along the same medium. It results in the formation of a new wave pattern.", ta: "குறுக்கீட்டு விளைவு என்பது ஒரே ஊடகத்தில் பயணிக்கும் இரண்டு அலைகள் சந்திக்கும்போது ஏற்படும் நிகழ்வு. இது ஒரு புதிய அலை வடிவத்தை உருவாக்குகிறது." }, constructiveDesc: { en: "<strong>Constructive Interference:</strong> Occurs when waves add up to make a larger amplitude resultant wave (e.g., crest meets crest). This happens when waves are in phase (or phase difference is a multiple of 2π or 360°).", ta: "<strong>ஆக்கக் குறுக்கீடு:</strong> அலைகள் கூடி ஒரு பெரிய வீச்சுடைய விளைவு அலையை உருவாக்கும்போது ஏற்படுகிறது (எ.கா., முகடு முகடுடன் встречается). அலைகள் ஒரே கட்டத்தில் இருக்கும்போது (அல்லது கட்ட வேறுபாடு 2π அல்லது 360° இன் மடங்காக இருக்கும்போது) இது நிகழ்கிறது." }, destructiveDesc: { en: "<strong>Destructive Interference:</strong> Occurs when waves add up to make a smaller amplitude (or zero) resultant wave (e.g., crest meets trough). This happens when waves are out of phase (phase difference is an odd multiple of π or 180°).", ta: "<strong>அழிவுக் குறுக்கீடு:</strong> அலைகள் கூடி ஒரு சிறிய வீச்சு (அல்லது பூஜ்ஜியம்) கொண்ட விளைவு அலையை உருவாக்கும்போது ஏற்படுகிறது (எ.கா., முகடு அகடுடன் встречается). அலைகள் கட்டத்திற்கு வெளியே இருக்கும்போது (கட்ட வேறுபாடு π அல்லது 180° இன் ஒற்றைப்படை மடங்காக இருக்கும்போது) இது நிகழ்கிறது." }, beatsTitle: { en: "Beats (f₁ ≈ f₂)", ta: "விம்மல்கள் (f₁ ≈ f₂)" }, beatsDesc: { en: "If two waves of slightly different frequencies interfere, the resultant amplitude varies periodically over time, creating \"beats\". The beat frequency is <code>f_beat = |f₁ - f₂|</code>.", ta: "சற்று மாறுபட்ட அதிர்வெண்கள் கொண்ட இரண்டு அலைகள் குறுக்கிட்டால், விளைவான வீச்சு காலப்போக்கில் குறிப்பிட்ட கால இடைவெளியில் மாறுபட்டு, \"விம்மல்களை\" உருவாக்குகிறது. விம்மல் அதிர்வெண் <code>f_விம்மல் = |f₁ - f₂|</code>." }, standingTitle: { en: "Standing Waves (Conceptual)", ta: "நிலை அலைகள் (கருத்து)" }, standingDesc: { en: "If two identical waves (same A, f, λ) travel in opposite directions, they can form a standing wave, which has fixed points of zero amplitude (nodes) and maximum amplitude (antinodes). (This simulation primarily shows co-directional waves).", ta: "ஒரே மாதிரியான இரண்டு அலைகள் (ஒரே A, f, λ) எதிர் திசைகளில் பயணித்தால், அவை ஒரு நிலை அலையை உருவாக்கலாம், இது பூஜ்ஜிய வீச்சின் நிலையான புள்ளிகளையும் (கணுக்கள்) மற்றும் அதிகபட்ச வீச்சின் புள்ளிகளையும் (எதிர் கணுக்கள்) கொண்டிருக்கும். (இந்த உருவகப்படுத்துதல் முக்கியமாக ஒரே திசையில் செல்லும் அலைகளைக் காட்டுகிறது)." }, tipsSuperTitle: { en: "Simulation Tips", ta: "உருவகப்படுத்துதல் குறிப்புகள்" }, tipPhaseSuper: { en: "Adjust initial phases (φ₁ & φ₂) to observe constructive and destructive interference. Try making them 0° and 180° apart.", ta: "ஆக்க மற்றும் அழிவு குறுக்கீட்டை கவனிக்க தொடக்க கட்டங்களை (φ₁ & φ₂) சரிசெய்யவும். அவற்றை 0° மற்றும் 180° இடைவெளியில் அமைக்கவும்." }, tipFreqSuper: { en: "Set frequencies (f₁ & f₂) very close to each other to observe the beat phenomenon (slow amplitude modulation of the resultant wave).", ta: "விம்மல் நிகழ்வை (விளைவு அலையின் மெதுவான வீச்சு பண்பேற்றம்) கவனிக்க அதிர்வெண்களை (f₁ & f₂) மிக நெருக்கமாக அமைக்கவும்." }, tipEqualSuper: { en: "Set A₁=A₂, f₁=f₂, λ₁=λ₂ and φ₁=0°, φ₂=180° for maximum destructive interference.", ta: "அதிகபட்ச அழிவு குறுக்கீட்டிற்கு A₁=A₂, f₁=f₂, λ₁=λ₂ மற்றும் φ₁=0°, φ₂=180° என அமைக்கவும்." } };
        function updateNotesLanguageSuper(lang) { document.querySelectorAll('[data-lang-key]').forEach(element => { const key = element.getAttribute('data-lang-key'); if (languageDataSuper[key] && languageDataSuper[key][lang]) { element.innerHTML = languageDataSuper[key][lang]; } }); langToggleButtonSuper.textContent = lang === 'en' ? 'தமிழ்' : 'English'; }
        langToggleButtonSuper.addEventListener('click', (event) => { event.stopPropagation(); currentNotesLanguageSuper = (currentNotesLanguageSuper === 'en') ? 'ta' : 'en'; updateNotesLanguageSuper(currentNotesLanguageSuper); });
        function resizeCanvasSuper() { canvas.width = canvas.offsetWidth; canvas.height = 400; updateParametersSuperposition(); }
        document.addEventListener('DOMContentLoaded', () => {
            resizeCanvasSuper(); window.addEventListener('resize', resizeCanvasSuper);
            updateNotesLanguageSuper(currentNotesLanguageSuper);
            const notesSection = document.getElementById('notesSectionSuper');
            const notesHeader = notesSection.querySelector('.notes-header');
            if (notesHeader && notesSection) { notesHeader.addEventListener('click', (event) => { if (event.target !== langToggleButtonSuper && !langToggleButtonSuper.contains(event.target)) { notesSection.classList.toggle('notes-open'); } }); }
            // Trigger initial ramp for checked and non-zero amplitude waves
            if (showWave1Check.checked && A1_target > 0) triggerRampUp(1);
            if (showWave2Check.checked && A2_target > 0) triggerRampUp(2);
            if (!isPausedSuper) { lastTimestampSuper = performance.now(); animationFrameIdSuper = requestAnimationFrame(animateSuperposition); } else { drawFrameSuperposition(); }
        });
    </script>
</body>

</html>