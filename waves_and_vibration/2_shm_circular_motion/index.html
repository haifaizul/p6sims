<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Harmonic Motion Simulation - p6sims</title>
    <link rel="stylesheet" href="../../style.css">
    <style>
        /* Simulation Specific Overrides */
        .simulation-wrapper {
            max-width: 900px;
            /* Slightly wider for this sim */
        }

        .controls-panel {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .control-group:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .control-group.button-actions {
            justify-content: center;
            padding-top: 0.5rem;
            border-top: none;
        }

        .control-item {
            display: flex;
            align-items: center;
            flex: 1 1 250px;
        }

        .control-item label {
            min-width: 140px;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .control-item input[type="range"] {
            flex-grow: 1;
            margin: 0 10px;
        }

        .value-display {
            min-width: 60px;
            text-align: right;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            background: var(--bg-secondary);
            padding: 2px 6px;
            border-radius: 4px;
            color: var(--text-primary);
        }

        .info-panel-shm {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            background-color: var(--bg-secondary);
            padding: 1rem;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .info-panel-shm div {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .info-panel-shm strong {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
        }

        .info-panel-shm span {
            font-weight: 600;
            color: var(--primary-color);
            font-size: 1.1rem;
        }

        canvas#shmCanvas {
            width: 100%;
            height: auto;
            min-height: 450px;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            margin-bottom: 1.5rem;
        }

        /* Notes Section */
        .notes-section {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            overflow: hidden;
        }

        .notes-header {
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .notes-header h3 {
            margin: 0;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .notes-header::after {
            content: '▸';
            font-size: 1.2rem;
            color: var(--text-secondary);
            transition: transform 0.2s ease;
        }

        .notes-section.notes-open .notes-header::after {
            transform: rotate(90deg);
        }

        .notes-content {
            display: none;
            padding: 1.5rem;
            font-size: 0.95rem;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .notes-section.notes-open .notes-content {
            display: block;
        }

        .note-block {
            margin-bottom: 1.5rem;
        }

        .note-block:last-child {
            margin-bottom: 0;
        }

        .note-block h4 {
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .note-block ul {
            padding-left: 1.5rem;
            margin-top: 0.5rem;
        }

        .note-block li {
            margin-bottom: 0.25rem;
        }

        code {
            background: var(--bg-secondary);
            padding: 0.1em 0.3em;
            border-radius: 3px;
            font-size: 0.9em;
            color: var(--primary-color);
        }

        .lang-button {
            padding: 4px 10px;
            font-size: 0.75rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s;
        }

        .lang-button:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        /* Variables for Canvas Drawing (Synced with CSS) */
        :root {
            --vector-x-color: #3b82f6;
            --vector-v-color: #10b981;
            --vector-a-color: #ef4444;
            --energy-pe-color: #a855f7;
            --energy-ke-color: #f59e0b;
            --energy-total-color: #64748b;
            --graph-axis-color: #cbd5e1;
            --graph-grid-color: #e2e8f0;
        }
    </style>
</head>

<body>

    <header class="site-header">
        <div class="header-content">
            <a href="../../index.html" class="logo">p6sims</a>
            <nav class="site-nav">
                <a href="../../index.html#topics">Topics</a>
                <a href="../../index.html#about">About</a>
            </nav>
        </div>
    </header>

    <main class="container">
        <div class="simulation-wrapper">
            <div class="back-link">
                <a href="../../waves-vibration.html">← Back to Waves & Vibration</a>
            </div>

            <h1>Simple Harmonic Motion (SHM)</h1>

            <div class="controls-panel">
                <div class="control-group">
                    <div class="control-item">
                        <label for="amplitudeSHM">Amplitude (A)</label>
                        <input type="range" id="amplitudeSHM" min="20" max="100" value="80">
                        <span id="amplitudeSHMValue" class="value-display">80</span>
                    </div>
                    <div class="control-item">
                        <label for="angularFrequencySHM">Angular Freq. (ω)</label>
                        <input type="range" id="angularFrequencySHM" min="0.5" max="5" step="0.1" value="1">
                        <span id="angularFrequencySHMValue" class="value-display">1.0 rad/s</span>
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-item">
                        <label for="initialPhaseSHM">Initial Phase (φ)</label>
                        <input type="range" id="initialPhaseSHM" min="0" max="360" step="1" value="0">
                        <span id="initialPhaseSHMValue" class="value-display">0°</span>
                    </div>
                    <div class="control-item">
                        <!-- Spacer or additional control -->
                    </div>
                </div>
                <div class="control-group button-actions">
                    <button id="pausePlayButtonSHM" class="btn btn-primary">Pause</button>
                    <button id="resetButtonSHM" class="btn btn-secondary">Reset Time</button>
                </div>
            </div>

            <div class="info-panel-shm">
                <div><strong>Angle (θ)</strong> <span id="angleValue">0.0°</span></div>
                <div><strong>Displ. (x)</strong> <span id="displacementValue">0.0</span></div>
                <div><strong>Velocity (v)</strong> <span id="velocityValue">0.0</span></div>
                <div><strong>Accel. (a)</strong> <span id="accelerationValue">0.0</span></div>
                <div><strong>Freq. (f)</strong> <span id="frequencyValue">0.0 Hz</span></div>
                <div><strong>Period (T)</strong> <span id="periodValue">0.0 s</span></div>
            </div>

            <canvas id="shmCanvas"></canvas>

            <section id="notesSection" class="notes-section">
                <div class="notes-header">
                    <h3 data-lang-key="notesTitleSHM">SHM: Key Concepts & Equations</h3>
                    <button id="langToggleButtonSHM" class="lang-button" title="Change notes language">தமிழ்</button>
                </div>
                <div class="notes-content">
                    <div class="note-block">
                        <h4 data-lang-key="whatIsSHMTitle">What is Simple Harmonic Motion?</h4>
                        <p data-lang-key="whatIsSHMDesc">Simple Harmonic Motion (SHM) is a special type of periodic
                            motion where the restoring force on the moving object is directly proportional to the
                            object's displacement magnitude and acts towards the object's equilibrium position. This
                            results in a sinusoidal oscillation.</p>
                    </div>
                    <div class="note-block">
                        <h4 data-lang-key="ucmConnectionTitle">Connection to Uniform Circular Motion (UCM)</h4>
                        <p data-lang-key="ucmConnectionDesc1">SHM can be understood as the projection of an object
                            undergoing Uniform Circular Motion (UCM) onto one of its diameters. In this simulation, the
                            horizontally oscillating block's motion is the projection of the rotating point on the
                            reference circle (left) onto the horizontal (x) axis.</p>
                        <p data-lang-key="ucmConnectionDesc2">The angle <code>θ</code> of the rotating phasor in UCM is
                            given by <code>θ = ωt + φ</code>, where <code>ω</code> is the angular frequency and
                            <code>φ</code> is the initial phase angle.</p>
                    </div>
                    <div class="note-block">
                        <h4 data-lang-key="shmEquationsTitle">Key SHM Equations</h4>
                        <ul>
                            <li data-lang-key="eqX">Displacement: <code>x(t) = A cos(ωt + φ)</code></li>
                            <li data-lang-key="eqV">Velocity: <code>v(t) = dx/dt = -Aω sin(ωt + φ)</code></li>
                            <li data-lang-key="eqA">Acceleration: <code>a(t) = dv/dt = -Aω² cos(ωt + φ)</code></li>
                            <li data-lang-key="eqARel">Also: <code>a(t) = -ω²x(t)</code> (characteristic of SHM)</li>
                        </ul>
                        <p data-lang-key="eqVarsSHM"><em>Where: A=Amplitude, ω=Angular Frequency, φ=Initial Phase,
                                t=Time</em></p>
                        <p data-lang-key="relatedQuantities">Related quantities:</p>
                        <ul>
                            <li data-lang-key="eqFreq">Frequency: <code>f = ω / 2π</code></li>
                            <li data-lang-key="eqPeriod">Period: <code>T = 1 / f = 2π / ω</code></li>
                        </ul>
                    </div>
                    <div class="note-block">
                        <h4 data-lang-key="tipsSHMTitle">Simulation Tips</h4>
                        <ul>
                            <li data-lang-key="tipPhase">Change the "Initial Phase (φ)" to see how it shifts the
                                starting position of the oscillation and the graphs.</li>
                            <li data-lang-key="tipVectors">Observe the direction and magnitude of the velocity (green)
                                and acceleration (red) vectors on the oscillating block. Velocity is maximum at
                                equilibrium (x=0), while acceleration is maximum at extreme positions (x=±A).</li>
                            <li data-lang-key="tipGraphs">Notice the phase relationships between the x, v, and a graphs.
                                Velocity leads displacement by 90° (π/2 rad), and acceleration leads velocity by 90° (or
                                is 180° out of phase with displacement).</li>
                        </ul>
                    </div>
                </div>
            </section>
        </div>
    </main>

    <footer class="site-footer">
        <p>&copy; 2023 p6sims. Built by <a href="https://www.instagram.com/hai_faizul/" target="_blank">Hai</a>.</p>
    </footer>

    <script>
        const canvas = document.getElementById('shmCanvas');
        const ctx = canvas.getContext('2d');
        const amplitudeSlider = document.getElementById('amplitudeSHM');
        const angularFrequencySlider = document.getElementById('angularFrequencySHM');
        const initialPhaseSlider = document.getElementById('initialPhaseSHM');
        const pausePlayButton = document.getElementById('pausePlayButtonSHM');
        const resetButton = document.getElementById('resetButtonSHM');
        const amplitudeValueSpan = document.getElementById('amplitudeSHMValue');
        const angularFrequencyValueSpan = document.getElementById('angularFrequencySHMValue');
        const initialPhaseValueSpan = document.getElementById('initialPhaseSHMValue');
        const angleValueSpan = document.getElementById('angleValue');
        const displacementValueSpan = document.getElementById('displacementValue');
        const velocityValueSpan = document.getElementById('velocityValue');
        const accelerationValueSpan = document.getElementById('accelerationValue');
        const frequencyValueSpan = document.getElementById('frequencyValue');
        const periodValueSpan = document.getElementById('periodValue');

        let A, omega, phi0_rad;
        let timeSHM = 0;
        let isPausedSHM = false;
        let lastTimestampSHM = 0;
        let animationFrameIdSHM = null;

        const graphHistoryLength = 300;
        const graphTimeWindow = 10;
        let displacementHistory = [], velocityHistory = [], accelerationHistory = [], timeHistory = [];
        let potentialEnergyHistory = [], kineticEnergyHistory = [], totalEnergyHistory = [];
        const NOMINAL_MASS = 1;

        let paramUpdateTimeout = null;
        let majorParamChangeFlag = false;

        let ucmDisplayHeight, graphContainerStartY, totalGraphAreaHeight, individualGraphHeight;
        const GRAPH_PADDING = 20;

        function calculateLayoutConstants() {
            const MIN_GRAPH_HEIGHT = 80;
            const UCM_MAX_HEIGHT_ABS = Math.min(220, canvas.width * 0.4); // Cap UCM absolute height
            const UCM_HEIGHT_PERCENTAGE = 0.30;
            let proposedUCMHeight = canvas.height * UCM_HEIGHT_PERCENTAGE;
            ucmDisplayHeight = Math.min(proposedUCMHeight, UCM_MAX_HEIGHT_ABS);
            if (canvas.height < 450) { ucmDisplayHeight = Math.min(ucmDisplayHeight, canvas.height * 0.35); }
            ucmDisplayHeight = Math.max(120, ucmDisplayHeight); // Min height for UCM display

            graphContainerStartY = ucmDisplayHeight;
            totalGraphAreaHeight = canvas.height - ucmDisplayHeight;
            const numGraphs = 4;

            individualGraphHeight = totalGraphAreaHeight / numGraphs;
            if (individualGraphHeight < MIN_GRAPH_HEIGHT) {
                individualGraphHeight = MIN_GRAPH_HEIGHT;
                canvas.height = ucmDisplayHeight + (numGraphs * MIN_GRAPH_HEIGHT) + 10; // +10 for overall padding
            }
            canvas.style.height = `${canvas.height}px`;
        }

        function updateParametersSHM(isMajorChange = true) {
            A = parseFloat(amplitudeSlider.value);
            omega = parseFloat(angularFrequencySlider.value);
            const phi0_deg = parseFloat(initialPhaseSlider.value);
            phi0_rad = phi0_deg * (Math.PI / 180);
            amplitudeValueSpan.textContent = A.toFixed(0);
            angularFrequencyValueSpan.textContent = omega.toFixed(1) + " rad/s";
            initialPhaseValueSpan.textContent = phi0_deg.toFixed(0) + "°";
            const freq = omega / (2 * Math.PI);
            const period = (freq > 0) ? 1 / freq : Infinity;
            frequencyValueSpan.textContent = (freq > 0.001 ? freq.toFixed(2) : "0.00") + " Hz";
            periodValueSpan.textContent = (isFinite(period) ? period.toFixed(2) : "inf") + " s";
            if (isMajorChange || majorParamChangeFlag) { clearHistories(); majorParamChangeFlag = false; }
            if (isPausedSHM) { drawSHMFrame(); }
            else if (!animationFrameIdSHM) { lastTimestampSHM = performance.now(); animationFrameIdSHM = requestAnimationFrame(animateSHM); }
        }
        function clearHistories() { timeHistory = []; displacementHistory = []; velocityHistory = []; accelerationHistory = []; potentialEnergyHistory = []; kineticEnergyHistory = []; totalEnergyHistory = []; }
        function resetTimeSHM() { timeSHM = 0; majorParamChangeFlag = true; updateParametersSHM(true); if (isPausedSHM) { if (animationFrameIdSHM) cancelAnimationFrame(animationFrameIdSHM); animationFrameIdSHM = null; drawSHMFrame(); } else { lastTimestampSHM = performance.now(); if (!animationFrameIdSHM) animationFrameIdSHM = requestAnimationFrame(animateSHM); } }

        function drawSHMFrame() {
            if (!canvas || !ctx || !ucmDisplayHeight) return; // Ensure layout constants are set
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const ucmCenterX = (canvas.width * 0.45) / 2;
            const ucmCenterY = ucmDisplayHeight / 2;
            const radius = Math.min(A, ucmCenterX - 15, ucmCenterY - 15);
            const shmObjectAreaX = canvas.width * 0.45;
            const shmObjectCenterY = ucmCenterY;
            const shmObjectEqX = shmObjectAreaX + (canvas.width * (1 - 0.45)) / 2;
            const currentAngle = omega * timeSHM + phi0_rad;
            const x_val = A * Math.cos(currentAngle); const v_val = -A * omega * Math.sin(currentAngle); const a_val = -A * omega * omega * Math.cos(currentAngle);
            const k_spring = NOMINAL_MASS * omega * omega; const pe_val = 0.5 * k_spring * x_val * x_val; const ke_val = 0.5 * NOMINAL_MASS * v_val * v_val; const total_e_val = pe_val + ke_val;
            angleValueSpan.textContent = ((currentAngle * 180 / Math.PI) % 360).toFixed(1) + "°"; displacementValueSpan.textContent = x_val.toFixed(1); velocityValueSpan.textContent = v_val.toFixed(1); accelerationValueSpan.textContent = a_val.toFixed(1);
            if (!isPausedSHM) { timeHistory.push(timeSHM); displacementHistory.push(x_val); velocityHistory.push(v_val); accelerationHistory.push(a_val); potentialEnergyHistory.push(pe_val); kineticEnergyHistory.push(ke_val); totalEnergyHistory.push(total_e_val); while (timeHistory.length > graphHistoryLength || (timeHistory.length > 0 && timeSHM - timeHistory[0] > graphTimeWindow)) { timeHistory.shift(); displacementHistory.shift(); velocityHistory.shift(); accelerationHistory.shift(); potentialEnergyHistory.shift(); kineticEnergyHistory.shift(); totalEnergyHistory.shift(); } }

            ctx.save(); ctx.translate(ucmCenterX, ucmCenterY);
            ctx.beginPath(); ctx.moveTo(-radius - 10, 0); ctx.lineTo(radius + 10, 0); ctx.moveTo(0, -radius - 10); ctx.lineTo(0, radius + 10); ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--graph-axis-color').trim(); ctx.lineWidth = 0.5; ctx.stroke();
            ctx.beginPath(); ctx.arc(0, 0, radius, 0, 2 * Math.PI); ctx.strokeStyle = '#aaa'; ctx.lineWidth = 1; ctx.stroke();
            const ucmPhasorAngleScaleFactor = A === 0 ? 1 : radius / A;
            const phasorX = radius * Math.cos(currentAngle); const phasorY = -radius * Math.sin(currentAngle);
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(phasorX, phasorY); ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(); ctx.lineWidth = 2; ctx.stroke();
            ctx.beginPath(); ctx.arc(phasorX, phasorY, 4, 0, 2 * Math.PI); ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(); ctx.fill();
            ctx.beginPath(); ctx.moveTo(phasorX, phasorY); ctx.lineTo(phasorX, 0); ctx.setLineDash([2, 2]); ctx.strokeStyle = '#aaa'; ctx.stroke();
            ctx.beginPath(); ctx.arc(phasorX, 0, 5, 0, 2 * Math.PI); ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim(); ctx.fill();
            ctx.setLineDash([]); ctx.restore();

            const blockWidth = 30; const blockHeight = 30; const shmVisualDisplacement = x_val * ucmPhasorAngleScaleFactor;
            const currentBlockX = shmObjectEqX + shmVisualDisplacement;
            ctx.beginPath(); ctx.moveTo(shmObjectEqX - radius - 10, shmObjectCenterY); ctx.lineTo(shmObjectEqX + radius + 10, shmObjectCenterY); ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--graph-axis-color').trim(); ctx.lineWidth = 0.5; ctx.stroke();
            ctx.beginPath(); ctx.moveTo(ucmCenterX + phasorX, ucmCenterY); ctx.lineTo(currentBlockX - blockWidth / 2, shmObjectCenterY); ctx.setLineDash([2, 2]); ctx.strokeStyle = '#aaa'; ctx.stroke(); ctx.setLineDash([]);
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color').trim(); ctx.fillRect(currentBlockX - blockWidth / 2, shmObjectCenterY - blockHeight / 2, blockWidth, blockHeight); ctx.strokeStyle = 'darkgreen'; ctx.strokeRect(currentBlockX - blockWidth / 2, shmObjectCenterY - blockHeight / 2, blockWidth, blockHeight);

            // REVISED VECTOR DRAWING:
            const vectorBaseY = shmObjectCenterY + blockHeight / 2 + 10;
            const vectorSpacingY = 18;
            let currentVectorY = vectorBaseY;
            const maxVectorLength = Math.min(A, canvas.width * 0.15); // Cap vector length

            // X Vector
            let x_vec_scaled_len = (x_val / A) * maxVectorLength; // Scale by proportion to max possible length
            if (Math.abs(x_val) > 0.1) { drawArrow(ctx, shmObjectEqX, currentVectorY, shmObjectEqX + x_vec_scaled_len, currentVectorY, getComputedStyle(document.documentElement).getPropertyValue('--vector-x-color').trim(), "x"); }
            currentVectorY += vectorSpacingY;

            // V Vector
            let max_v_abs = A * omega; if (max_v_abs === 0) max_v_abs = 1; // Avoid division by zero
            let v_vec_scaled_len = (v_val / max_v_abs) * maxVectorLength;
            if (Math.abs(v_val) > 0.1) { drawArrow(ctx, currentBlockX, currentVectorY, currentBlockX + v_vec_scaled_len, currentVectorY, getComputedStyle(document.documentElement).getPropertyValue('--vector-v-color').trim(), "v"); }
            currentVectorY += vectorSpacingY;

            // A Vector
            let max_a_abs = A * omega * omega; if (max_a_abs === 0) max_a_abs = 1;
            let a_vec_scaled_len = (a_val / max_a_abs) * maxVectorLength;
            if (Math.abs(a_val) > 0.1) { drawArrow(ctx, currentBlockX, currentVectorY, currentBlockX + a_vec_scaled_len, currentVectorY, getComputedStyle(document.documentElement).getPropertyValue('--vector-a-color').trim(), "a"); }

            // GRAPHS
            const graphWidth = canvas.width - 2 * GRAPH_PADDING;
            const maxDispVal = Math.max(1, A); const maxVelVal = Math.max(1, A * omega); const maxAccVal = Math.max(1, A * omega * omega); const maxEnergyVal = Math.max(1, 0.5 * NOMINAL_MASS * omega * omega * A * A);
            let currentGraphPlotY = graphContainerStartY;

            drawSingleGraph(ctx, GRAPH_PADDING, currentGraphPlotY, graphWidth, individualGraphHeight, timeHistory, displacementHistory, maxDispVal, "Displacement (x)", getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim());
            currentGraphPlotY += individualGraphHeight;
            drawSingleGraph(ctx, GRAPH_PADDING, currentGraphPlotY, graphWidth, individualGraphHeight, timeHistory, velocityHistory, maxVelVal, "Velocity (v)", getComputedStyle(document.documentElement).getPropertyValue('--vector-v-color').trim());
            currentGraphPlotY += individualGraphHeight;
            drawSingleGraph(ctx, GRAPH_PADDING, currentGraphPlotY, graphWidth, individualGraphHeight, timeHistory, accelerationHistory, maxAccVal, "Acceleration (a)", getComputedStyle(document.documentElement).getPropertyValue('--vector-a-color').trim());
            currentGraphPlotY += individualGraphHeight;

            const energyGraphTopY = currentGraphPlotY + 10;
            const energyGraphPlotHeight = individualGraphHeight - 20;
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--graph-axis-color').trim(); ctx.lineWidth = 0.5;
            ctx.beginPath(); ctx.moveTo(GRAPH_PADDING, energyGraphTopY + energyGraphPlotHeight); ctx.lineTo(GRAPH_PADDING + graphWidth, energyGraphTopY + energyGraphPlotHeight); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(GRAPH_PADDING, energyGraphTopY); ctx.lineTo(GRAPH_PADDING, energyGraphTopY + energyGraphPlotHeight); ctx.stroke();
            drawVerticalGridLines(ctx, GRAPH_PADDING, energyGraphTopY, graphWidth, energyGraphPlotHeight, 5);
            ctx.fillStyle = "#333"; ctx.font = "12px Arial"; ctx.fillText("Energy (PE, KE, Total)", GRAPH_PADDING + 5, currentGraphPlotY + 8);
            drawEnergySubGraph(ctx, GRAPH_PADDING, energyGraphTopY, graphWidth, energyGraphPlotHeight, timeHistory, potentialEnergyHistory, maxEnergyVal, getComputedStyle(document.documentElement).getPropertyValue('--energy-pe-color').trim());
            drawEnergySubGraph(ctx, GRAPH_PADDING, energyGraphTopY, graphWidth, energyGraphPlotHeight, timeHistory, kineticEnergyHistory, maxEnergyVal, getComputedStyle(document.documentElement).getPropertyValue('--energy-ke-color').trim());
            drawEnergySubGraph(ctx, GRAPH_PADDING, energyGraphTopY, graphWidth, energyGraphPlotHeight, timeHistory, totalEnergyHistory, maxEnergyVal, getComputedStyle(document.documentElement).getPropertyValue('--energy-total-color').trim(), true);
        }

        function drawArrow(ctx, fromX, fromY, toX, toY, color, label) { const headLength = Math.min(10, Math.abs(toX - fromX) * 0.3 + Math.abs(toY - fromY) * 0.3); const dx = toX - fromX; const dy = toY - fromY; if (Math.abs(dx) < 1 && Math.abs(dy) < 1) { ctx.beginPath(); ctx.arc(fromX, fromY, 2, 0, 2 * Math.PI); ctx.fillStyle = color; ctx.fill(); if (label) { ctx.fillStyle = color; ctx.font = "bold 10px Arial"; ctx.textAlign = "center"; ctx.fillText(label, fromX, fromY - 5); } return; } const angle = Math.atan2(dy, dx); ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(fromX, fromY); ctx.lineTo(toX, toY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(toX, toY); ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6), toY - headLength * Math.sin(angle - Math.PI / 6)); ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6), toY - headLength * Math.sin(angle + Math.PI / 6)); ctx.closePath(); ctx.fill(); if (label) { ctx.fillStyle = color; ctx.font = "bold 10px Arial"; const labelXOffset = (dx > 0) ? -10 : 5; const labelYOffset = (Math.abs(dx) < 2) ? ((dy > 0) ? 12 : -5) : -5; ctx.textAlign = (dx > 0) ? "right" : "left"; ctx.fillText(label, toX + labelXOffset, toY + labelYOffset); } }
        function drawVerticalGridLines(ctx, x, y, width, height, numLines = 5) { ctx.save(); ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--graph-grid-color').trim(); ctx.lineWidth = 0.75; ctx.setLineDash([2, 2]); for (let i = 1; i < numLines; i++) { const lineX = x + (i * width / numLines); ctx.beginPath(); ctx.moveTo(lineX, y); ctx.lineTo(lineX, y + height); ctx.stroke(); } ctx.restore(); }
        function drawSingleGraph(ctx, x, y, width, height, timeData, valueData, maxValue, label, color) { if (timeData.length < 2) return; const graphContentHeight = height - 20; const graphCenterY = y + 10 + graphContentHeight / 2; ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--graph-axis-color').trim(); ctx.lineWidth = 0.5; ctx.beginPath(); ctx.moveTo(x, graphCenterY); ctx.lineTo(x + width, graphCenterY); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x, y + 10); ctx.lineTo(x, y + 10 + graphContentHeight); ctx.stroke(); drawVerticalGridLines(ctx, x, y + 10, width, graphContentHeight, 5); ctx.fillStyle = color; ctx.font = "12px Arial"; ctx.fillText(label, x + 5, y + 8); ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.beginPath(); const lastTimePoint = timeData[timeData.length - 1]; let graphMinTime, effectiveTimeSpan; if (timeSHM <= graphTimeWindow || timeData.length < graphHistoryLength / 2) { graphMinTime = 0; effectiveTimeSpan = Math.max(1e-6, lastTimePoint); if (effectiveTimeSpan === 0 && timeData.length > 0) effectiveTimeSpan = graphTimeWindow / 4; } else { graphMinTime = lastTimePoint - graphTimeWindow; effectiveTimeSpan = graphTimeWindow; } let firstPointOnGraph = false; for (let i = 0; i < timeData.length; i++) { if (timeData[i] < graphMinTime && i < timeData.length - 1 && timeData[i + 1] < graphMinTime) continue; const plotX = x + ((timeData[i] - graphMinTime) / effectiveTimeSpan) * width; const plotY = graphCenterY - (valueData[i] / (maxValue || 1)) * (graphContentHeight / 2); const clampedY = Math.max(y + 10, Math.min(y + 10 + graphContentHeight, plotY)); if (!firstPointOnGraph) { ctx.moveTo(plotX, clampedY); firstPointOnGraph = true; } else { ctx.lineTo(plotX, clampedY); } } ctx.stroke(); }
        function drawEnergySubGraph(ctx, x, y, width, graphPlotHeight, timeData, valueData, maxValue, color, isDashed = false) { if (timeData.length < 2) return; ctx.strokeStyle = color; ctx.lineWidth = 1.5; if (isDashed) ctx.setLineDash([3, 3]); ctx.beginPath(); const lastTimePoint = timeData[timeData.length - 1]; let graphMinTime, effectiveTimeSpan; if (timeSHM <= graphTimeWindow || timeData.length < graphHistoryLength / 2) { graphMinTime = 0; effectiveTimeSpan = Math.max(1e-6, lastTimePoint); if (effectiveTimeSpan === 0 && timeData.length > 0) effectiveTimeSpan = graphTimeWindow / 4; } else { graphMinTime = lastTimePoint - graphTimeWindow; effectiveTimeSpan = graphTimeWindow; } let firstPointOnGraph = false; for (let i = 0; i < timeData.length; i++) { if (timeData[i] < graphMinTime && i < timeData.length - 1 && timeData[i + 1] < graphMinTime) continue; const plotX = x + ((timeData[i] - graphMinTime) / effectiveTimeSpan) * width; const plotY = (y + graphPlotHeight) - (valueData[i] / (maxValue || 1)) * graphPlotHeight; const clampedY = Math.max(y, Math.min(y + graphPlotHeight, plotY)); if (!firstPointOnGraph) { ctx.moveTo(plotX, clampedY); firstPointOnGraph = true; } else { ctx.lineTo(plotX, clampedY); } } ctx.stroke(); if (isDashed) ctx.setLineDash([]); }
        function animateSHM(timestamp) { if (!isPausedSHM) { if (!lastTimestampSHM) lastTimestampSHM = timestamp; const deltaTime = (timestamp - lastTimestampSHM) / 1000; lastTimestampSHM = timestamp; if (!isNaN(deltaTime) && deltaTime > 0 && deltaTime < 0.5) timeSHM += deltaTime; } drawSHMFrame(); if (!isPausedSHM) animationFrameIdSHM = requestAnimationFrame(animateSHM); else { if (animationFrameIdSHM) cancelAnimationFrame(animationFrameIdSHM); animationFrameIdSHM = null; } }
        function createDebouncedParamUpdate(isMajor) { return () => { majorParamChangeFlag = majorParamChangeFlag || isMajor; clearTimeout(paramUpdateTimeout); paramUpdateTimeout = setTimeout(() => { updateParametersSHM(majorParamChangeFlag); majorParamChangeFlag = false; }, 50); }; }
        amplitudeSlider.addEventListener('input', createDebouncedParamUpdate(true)); angularFrequencySlider.addEventListener('input', createDebouncedParamUpdate(true)); initialPhaseSlider.addEventListener('input', createDebouncedParamUpdate(false));
        pausePlayButton.addEventListener('click', () => { isPausedSHM = !isPausedSHM; pausePlayButton.textContent = isPausedSHM ? 'Play' : 'Pause'; if (!isPausedSHM) { lastTimestampSHM = performance.now(); if (!animationFrameIdSHM) animationFrameIdSHM = requestAnimationFrame(animateSHM); } else { if (animationFrameIdSHM) cancelAnimationFrame(animationFrameIdSHM); animationFrameIdSHM = null; } });
        resetButton.addEventListener('click', resetTimeSHM);
        const langToggleButtonSHM = document.getElementById('langToggleButtonSHM'); let currentNotesLanguageSHM = 'en';
        const languageDataSHM = { notesTitleSHM: { en: "SHM: Key Concepts & Equations", ta: "SHM: முக்கிய கருத்துகள் & சமன்பாடுகள்" }, whatIsSHMTitle: { en: "What is Simple Harmonic Motion?", ta: "எளிய சீரிசை இயக்கம் என்றால் என்ன?" }, whatIsSHMDesc: { en: "Simple Harmonic Motion (SHM) is a special type of periodic motion where the restoring force on the moving object is directly proportional to the object's displacement magnitude and acts towards the object's equilibrium position. This results in a sinusoidal oscillation.", ta: "எளிய சீரிசை இயக்கம் (SHM) என்பது ஒரு சிறப்பு வகை சீரான அலைவு ஆகும், இதில் நகரும் பொருளின் மீது செயல்படும் மீள்விசை, பொருளின் இடப்பெயர்ச்சி அளவுக்கு நேர்விகிதத்திலும், பொருளின் சமநிலை நிலையை நோக்கியும் இருக்கும். இது சைன் வடிவ அலைவை ஏற்படுத்துகிறது." }, ucmConnectionTitle: { en: "Connection to Uniform Circular Motion (UCM)", ta: "சீரான வட்ட இயக்கத்துடன் (UCM) தொடர்பு" }, ucmConnectionDesc1: { en: "SHM can be understood as the projection of an object undergoing Uniform Circular Motion (UCM) onto one of its diameters. In this simulation, the horizontally oscillating block's motion is the projection of the rotating point on the reference circle (left) onto the horizontal (x) axis.", ta: "SHM என்பதை சீரான வட்ட இயக்கத்தில் (UCM) உள்ள ஒரு பொருளின் இயக்கத்தை அதன் விட்டங்களில் ஒன்றின் மீது விழச்செய்வதன் மூலம் புரிந்து கொள்ளலாம். இந்த உருவகப்படுத்துதலில், கிடைமட்டமாக அதிர்வுறும் கட்டையின் இயக்கம், மேற்கோள் வட்டத்தில் (இடது) சுழலும் புள்ளியின் கிடைமட்ட (x) அச்சின் மீதான வீழல் ஆகும்." }, ucmConnectionDesc2: { en: "The angle <code>θ</code> of the rotating phasor in UCM is given by <code>θ = ωt + φ</code>, where <code>ω</code> is the angular frequency and <code>φ</code> is the initial phase angle.", ta: "UCM-இல் சுழலும் திசையனின் கோணம் <code>θ</code> என்பது <code>θ = ωt + φ</code> ஆல் கொடுக்கப்படுகிறது, இங்கு <code>ω</code> என்பது கோண அதிர்வெண் மற்றும் <code>φ</code> என்பது தொடக்க கட்ட கோணம்." }, shmEquationsTitle: { en: "Key SHM Equations", ta: "முக்கிய SHM சமன்பாடுகள்" }, eqX: { en: "Displacement: <code>x(t) = A cos(ωt + φ)</code>", ta: "இடப்பெயர்ச்சி: <code>x(t) = A cos(ωt + φ)</code>" }, eqV: { en: "Velocity: <code>v(t) = dx/dt = -Aω sin(ωt + φ)</code>", ta: "திசைவேகம்: <code>v(t) = dx/dt = -Aω sin(ωt + φ)</code>" }, eqA: { en: "Acceleration: <code>a(t) = dv/dt = -Aω² cos(ωt + φ)</code>", ta: "முடுக்கம்: <code>a(t) = dv/dt = -Aω² cos(ωt + φ)</code>" }, eqARel: { en: "Also: <code>a(t) = -ω²x(t)</code> (characteristic of SHM)", ta: "மேலும்: <code>a(t) = -ω²x(t)</code> (SHM-இன் பண்பு)" }, eqVarsSHM: { en: "<em>Where: A=Amplitude, ω=Angular Frequency, φ=Initial Phase, t=Time</em>", ta: "<em>இங்கு: A=வீச்சு, ω=கோண அதிர்வெண், φ=தொடக்க கட்டம், t=நேரம்</em>" }, relatedQuantities: { en: "Related quantities:", ta: "தொடர்புடைய அளவுகள்:" }, eqFreq: { en: "Frequency: <code>f = ω / 2π</code>", ta: "அதிர்வெண்: <code>f = ω / 2π</code>" }, eqPeriod: { en: "Period: <code>T = 1 / f = 2π / ω</code>", ta: "அலைவு காலம்: <code>T = 1 / f = 2π / ω</code>" }, tipsSHMTitle: { en: "Simulation Tips", ta: "உருவகப்படுத்துதல் குறிப்புகள்" }, tipPhase: { en: "Change the \"Initial Phase (φ)\" to see how it shifts the starting position of the oscillation and the graphs.", ta: "\"தொடக்க கட்டம் (φ)\" மாற்றுவதன் மூலம் அலைவின் ஆரம்ப நிலை மற்றும் வரைபடங்கள் எவ்வாறு மாறுகின்றன என்பதைக் காணவும்." }, tipVectors: { en: "Observe the direction and magnitude of the velocity (green) and acceleration (red) vectors on the oscillating block. Velocity is maximum at equilibrium (x=0), while acceleration is maximum at extreme positions (x=±A).", ta: "அதிர்வுறும் கட்டையின் மீது திசைவேகம் (பச்சை) மற்றும் முடுக்கம் (சிவப்பு) திசையன்களின் திசை மற்றும் அளவைக் கவனியுங்கள். திசைவேகம் சமநிலையில் (x=0) அதிகபட்சமாகவும், முடுக்கம் चरम நிலைகளில் (x=±A) அதிகபட்சமாகவும் இருக்கும்." }, tipGraphs: { en: "Notice the phase relationships between the x, v, and a graphs. Velocity leads displacement by 90° (π/2 rad), and acceleration leads velocity by 90° (or is 180° out of phase with displacement).", ta: "x, v, மற்றும் a வரைபடங்களுக்கு இடையிலான கட்ட உறவுகளைக் கவனியுங்கள். திசைவேகம் இடப்பெயர்ச்சியை 90° (π/2 ரேடியன்) முந்துகிறது, மேலும் முடுக்கம் திசைவேகத்தை 90° முந்துகிறது (அல்லது இடப்பெயர்ச்சியுடன் 180° கட்டத்திற்கு வெளியே உள்ளது)." } };
        function updateNotesLanguageSHM(lang) { document.querySelectorAll('[data-lang-key]').forEach(element => { const key = element.getAttribute('data-lang-key'); if (languageDataSHM[key] && languageDataSHM[key][lang]) { element.innerHTML = languageDataSHM[key][lang]; } }); langToggleButtonSHM.textContent = lang === 'en' ? 'தமிழ்' : 'English'; }
        langToggleButtonSHM.addEventListener('click', (event) => { event.stopPropagation(); currentNotesLanguageSHM = (currentNotesLanguageSHM === 'en') ? 'ta' : 'en'; updateNotesLanguageSHM(currentNotesLanguageSHM); });
        document.addEventListener('DOMContentLoaded', () => { canvas.width = canvas.offsetWidth || 800; canvas.height = 750; calculateLayoutConstants(); updateParametersSHM(true); updateNotesLanguageSHM(currentNotesLanguageSHM); const notesSection = document.getElementById('notesSection'); const notesHeader = notesSection.querySelector('.notes-header'); if (notesHeader && notesSection) { notesHeader.addEventListener('click', (event) => { if (event.target !== langToggleButtonSHM && !langToggleButtonSHM.contains(event.target)) { notesSection.classList.toggle('notes-open'); } }); } if (!isPausedSHM) { lastTimestampSHM = performance.now(); animationFrameIdSHM = requestAnimationFrame(animateSHM); } else { drawSHMFrame(); } });
    </script>
</body>

</html>